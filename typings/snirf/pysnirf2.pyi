"""
This type stub file was generated by pyright.
"""

import h5py
import os
import sys
import time
from abc import ABC
from collections.abc import MutableSequence

"""Module for reading, writing and validating SNIRF files.

SNIRF files are HDF5 files designed to facilitate the sharing of near-infrared
spectrocopy data. Their specification is defined at https://github.com/fNIRS/snirf.

This library wraps each HDF5 Group and offers a Pythonic interface on lists
of like-Groups which the SNIRF specification calls "indexed Groups".

Example:
    Load a file:

        >>> from snirf import Snirf
        >>> with Snirf(<filename>) as s:
            ...

Maintained by the Boston University Neurophotonics Center
"""
if sys.version_info[0] < 3:
    ...
class SnirfFormatError(Warning):
    """Raised when SNIRF-specific error prevents file from loading properly."""
    ...


if os.name == 'nt':
    ...
_printr = ...
_printg = ...
_printb = ...
_printm = ...
_colored = ...
_loggers = ...
_logfile = ...
if os.path.exists(_logfile):
    _logger = ...
else:
    _logger = ...
_varlen_str_type = ...
_DTYPE_FLOAT32 = ...
_DTYPE_FLOAT64 = ...
_DTYPE_INT32 = ...
_DTYPE_INT64 = ...
_DTYPE_FIXED_LEN_STR = ...
_DTYPE_VAR_LEN_STR = ...
_INT_DTYPES = ...
_FLOAT_DTYPES = ...
_STR_DTYPES = ...
_SEVERITY_LEVELS = ...
_SEVERITY_COLORS = ...
_CODES = ...
class ValidationIssue:
    """Information about the validity of a given SNIRF file location.

    Properties:
        location: A relative HDF5 name corresponding to the location of the issue
        name: A string describing the issue. Must be predefined in `_CODES`
        id: An integer corresponding to the predefined error type
        severity: An integer ranking the serverity level of the issue.
            0 OK, Nothing remarkable
            1 Potentially useful `INFO`
            2 `WARNING`, the file is valid but exhibits undefined behavior or features marked deprecation
            3 `FATAL`, The file is invalid.
        message: A string containing a more verbose description of the issue
    """
    def __init__(self, name: str, location: str) -> None:
        ...
    
    def __repr__(self):
        ...
    
    def dictize(self): # -> dict[str, Unknown]:
        """Return dictionary representation of Issue."""
        ...
    


class ValidationResult:
    """The result of Snirf file validation routines.

    Validation results in a list of issues. Each issue records information about
    the validity of each location (each named Dataset and Group) in a SNIRF file.
    ValidationResult organizes the issues catalogued during validation and affords interfaces
    to retrieve and display them.

    ```
    <ValidationResult> = <Snirf instance>.validate()
     <ValidationResult> = validateSnirf(<path>)
    ```
    """
    def __init__(self) -> None:
        """`ValidationResult` should only be created by a `Snirf` instance's `validate` method."""
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def is_valid(self) -> bool:
        """Returns True if no `FATAL` issues were catalogued during validation."""
        ...
    
    @property
    def issues(self): # -> list[Unknown]:
        """A comprehensive list of all `ValidationIssue` instances for the result."""
        ...
    
    @property
    def locations(self): # -> list[Unknown]:
        """A list of the HDF5 location associated with each issue."""
        ...
    
    @property
    def codes(self): # -> list[Unknown]:
        """A list of each unique code name associated with all catalogued issues."""
        ...
    
    @property
    def errors(self): # -> list[Unknown]:
        """A list of the `FATAL` issues catalogued during validation."""
        ...
    
    @property
    def warnings(self): # -> list[Unknown]:
        """A list of the `WARNING` issues catalogued during validation."""
        ...
    
    @property
    def info(self): # -> list[Unknown]:
        """A list of the `INFO` issues catalogued during validation."""
        ...
    
    def serialize(self, indent=...): # -> str:
        """Render serialized JSON ValidationResult."""
        ...
    
    def display(self, severity=...): # -> None:
        """Reads the contents of an `h5py.Dataset` to an array of `dtype=str`.

        Args:
            severity: An `int` which sets the minimum severity message to
            display. Default is 2.
                severity=0 All messages will be shown, including `OK`
                severity=1 Prints `INFO`, `WARNING`, and `FATAL` messages
                severity=2 Prints `WARNING` and `FATAL` messages
                severity=3 Prints only `FATAL` error messages
        """
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __repr__(self): # -> str:
        ...
    


class SnirfConfig:
    """Structure containing Snirf-wide data and settings.

    Properties:
        logger (logging.Logger): The logger that the Snirf instance writes to
        dynamic_loading (bool): If True, data is loaded from the HDF5 file only on access via property
    """
    def __init__(self) -> None:
        ...
    


class _AbsentDatasetType:
    ...


class _AbsentGroupType:
    ...


class _PresentDatasetType:
    ...


_AbsentDataset = ...
_AbsentGroup = ...
_PresentDataset = ...
class Group(ABC):
    def __init__(self, varg, cfg: SnirfConfig) -> None:
        """Wrapper for an HDF5 Group element defined by SNIRF.

        Base class for an HDF5 Group element defined by SNIRF. Must be created with a
        Group ID or string specifying a complete path relative to file root--in
        the latter case, the wrapper will not correspond to a real HDF5 group on
        disk until `_save()` (with no arguments) is executed for the first time

        Args:
            varg (h5py.h5g.GroupID or str): Either a string which maps to a future Group location or an ID corresponding to a current one on disk
            cfg (SnirfConfig): Injected configuration of parent `Snirf` instance
        """
        ...
    
    def save(self, *args): # -> None:
        """Group level save to a SNIRF file on disk.

        Args:
            args (str or h5py.File): A path to a closed SNIRF file on disk or an open `h5py.File` instance

        Examples:
            save can be called on a Group already on disk to overwrite the current contents:
            >>> mysnirf.nirs[0].probe.save()

            or using a new filename to write the Group there:
            >>> mysnirf.nirs[0].probe.save(<new destination>)
        """
        ...
    
    @property
    def filename(self): # -> None:
        """The filename the Snirf object was loaded from and will save to.

        None if not associated with a Group on disk.
        """
        ...
    
    @property
    def location(self): # -> str:
        """The HDF5 relative location indentifier.

        None if not associataed with a Group on disk.
        """
        ...
    
    def is_empty(self): # -> bool:
        """If the Group has no member Groups or Datasets.

        Returns:
            bool: True if empty, False if not
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    


class IndexedGroup(MutableSequence, ABC):
    _name: str = ...
    _element: Group = ...
    def __init__(self, parent: Group, cfg: SnirfConfig) -> None:
        """Represents several Groups which share a name, an "indexed group".

        Represents the "indexed group" which is defined by v1.0 of the SNIRF
        specification as:
            If a data element is an HDF5 group and contains multiple sub-groups,
            it is referred to as an indexed group. Each element of the sub-group
            is uniquely identified by appending a string-formatted index (starting
            from 1, with no preceding zeros) in the name, for example, /.../name1
            denotes the first sub-group of data element name, and /.../name2
            denotes the 2nd element, and so on.

        Because the indexed group is not a true HDF5 group but rather an
        iterable list of HDF5 groups, it takes a base group or file and
        searches its keys, appending the appropriate elements to itself
        in order.

        The appropriate elements are identified using the `_name` attribute: if
        a key begins with `_name` and ends with a number, or is equal to `_name`.

        Args:
            parent (h5py.h5g.Group): An HDF5 group which is the parent of the indexed groups
            cfg (SnirfConfig): Injected configuration of parent `Snirf` instance

        """
        ...
    
    @property
    def filename(self): # -> None:
        """The filename the Snirf object was loaded from and will save to."""
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, i):
        ...
    
    def __delitem__(self, i): # -> None:
        ...
    
    def __setitem__(self, i, item): # -> None:
        ...
    
    def __getattr__(self, name): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def is_empty(self): # -> bool:
        """Returns True if the Indexed Group has no member Groups with contents.

        Returns:
            bool: True if empty, False if not
        """
        ...
    
    def insert(self, i, item): # -> None:
        """Insert a new Group into the IndexedGroup.

        Args:
            i (int): an index
            item: must be of type _element
        """
        ...
    
    def append(self, item): # -> None:
        """Append a new Group to the IndexedGroup.

        Args:
            item: must be of type _element
        """
        ...
    
    def save(self, *args): # -> None:
        """Save the groups to a SNIRF file on disk.

        When saving, the naming convention defined by the SNIRF spec is enforced:
        groups are named `/<name>1`, `/<name>2`, `/<name>3`, and so on.

        Args:
            args (str or h5py.File): A path to a closed SNIRF file on disk or an open `h5py.File` instance

        Examples:
            save can be called on an Indexed Group already on disk to overwrite the current contents:
            >>> mysnirf.nirs[0].stim.save()

            or using a new filename to write the Indexed Group there:
            >>> mysnirf.nirs[0].stim.save(<new destination>)
        """
        ...
    
    def appendGroup(self): # -> None:
        """Insert a new Group at the end of the Indexed Group.

        Creates an empty Group with the appropriate name at the end of the
        list of Groups managed by the IndexedGroup.
        """
        ...
    
    def insertGroup(self, i): # -> None:
        """Insert a new Group following the index given.

        Creates an empty Group with a placeholder name within the list of Groups
        managed by the IndexedGroup. The placeholder name will be replaced with a
        name with the correct order once `save` is called.

        Args:
            i (int): the position at which to insert the new Group
        """
        ...
    


class MetaDataTags(Group):
    """Wrapper for Group of type `metaDataTags`.

    The `metaDataTags` group contains the metadata associated with the measurements.
    Each metadata record is represented as a dataset under this group - with the name of
    the record, i.e. the key, as the dataset's name, and the value of the record as the 
    actual data stored in the dataset. Each metadata record can potentially have different 
    data types. Sub-groups should not be used to organize metadata records: a member of the `metaDataTags` Group must be a Dataset.

    The below five metadata records are minimally required in a SNIRF file

    """
    def __init__(self, var, cfg: SnirfConfig) -> None:
        ...
    
    @property
    def SubjectID(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `SubjectID`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This record stores the string-valued ID of the study subject or experiment.

        """
        ...
    
    @SubjectID.setter
    def SubjectID(self, value): # -> None:
        ...
    
    @SubjectID.deleter
    def SubjectID(self): # -> None:
        ...
    
    @property
    def MeasurementDate(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `MeasurementDate`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This record stores the date of the measurement as a string. The format of the date
        string must either be `"unknown"`, or follow the ISO 8601 date string format `YYYY-MM-DD`, where
        - `YYYY` is the 4-digit year
        - `MM` is the 2-digit month (padding zero if a single digit)
        - `DD` is the 2-digit date (padding zero if a single digit)

        """
        ...
    
    @MeasurementDate.setter
    def MeasurementDate(self, value): # -> None:
        ...
    
    @MeasurementDate.deleter
    def MeasurementDate(self): # -> None:
        ...
    
    @property
    def MeasurementTime(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `MeasurementTime`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This record stores the time of the measurement as a string. The format of the time
        string must either be `"unknown"` or follow the ISO 8601 time string format `hh:mm:ss.sTZD`, where
        - `hh` is the 2-digit hour
        - `mm` is the 2-digit minute
        - `ss` is the 2-digit second
        - `.s` is 1 or more digit representing a decimal fraction of a second (optional)
        - `TZD` is the time zone designator (`Z` or `+hh:mm` or `-hh:mm`)

        """
        ...
    
    @MeasurementTime.setter
    def MeasurementTime(self, value): # -> None:
        ...
    
    @MeasurementTime.deleter
    def MeasurementTime(self): # -> None:
        ...
    
    @property
    def LengthUnit(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `LengthUnit`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This record stores the **case-sensitive** SI length unit used in this 
        measurement. Sample length units include "mm", "cm", and "m". A value of 
        "um" is the same as "mm", i.e. micrometer.

        """
        ...
    
    @LengthUnit.setter
    def LengthUnit(self, value): # -> None:
        ...
    
    @LengthUnit.deleter
    def LengthUnit(self): # -> None:
        ...
    
    @property
    def TimeUnit(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `TimeUnit`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This record stores the **case-sensitive** SI time unit used in this 
        measurement. Sample time units include "s", and "ms". A value of "us" 
        is the same as "ms", i.e. microsecond.

        """
        ...
    
    @TimeUnit.setter
    def TimeUnit(self, value): # -> None:
        ...
    
    @TimeUnit.deleter
    def TimeUnit(self): # -> None:
        ...
    
    @property
    def FrequencyUnit(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `FrequencyUnit`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This record stores the **case-sensitive** SI frequency unit used in 
        this measurement. Sample frequency units "Hz", "MHz" and "GHz". Please
        note that "mHz" is milli-Hz while "MHz" denotes "mega-Hz" according to
        SI unit system.

        We do not limit the total number of metadata records in the `metaDataTags`. Users
        can add additional customized metadata records; no duplicated metadata record names
        are allowed.

        Additional metadata record samples can be found in the below table.

        | Metadata Key Name | Metadata value |
        |-------------------|----------------|
        |ManufacturerName | "Company Name" |
        |Model | "Model Name" |
        |SubjectName | "LastName, FirstName" |
        |DateOfBirth | "YYYY-MM-DD" |
        |AcquisitionStartTime | "1569465620" |
        |StudyID | "Infant Brain Development" |
        |StudyDescription | "In this study, we measure ...." |
        |AccessionNumber | "##########################" |
        |InstanceNumber  | 2 |
        |CalibrationFileName | "phantomcal_121015.snirf" |
        |UnixTime | "1569465667" |

        The metadata records `"StudyID"` and `"AccessionNumber"` are unique strings that 
        can be used to link the current dataset to a particular study and a particular 
        procedure, respectively. The `"StudyID"` tag is similar to the DICOM tag "Study 
        ID" (0020,0010) and `"AccessionNumber"` is similar to the DICOM tag "Accession 
        Number"(0008,0050), as defined in the DICOM standard (ISO 12052).

        The metadata record `"InstanceNumber"` is defined similarly to the DICOM tag 
        "Instance Number" (0020,0013), and can be used as the sequence number to group 
        multiple datasets into a larger dataset - for example, concatenating streamed 
        data segments during a long measurement session.

        The metadata record `"UnixTime"` defines the Unix Epoch Time, i.e. the total elapse
        time in seconds since 1970-01-01T00:00:00Z (UTC) minus the leap seconds.

        """
        ...
    
    @FrequencyUnit.setter
    def FrequencyUnit(self, value): # -> None:
        ...
    
    @FrequencyUnit.deleter
    def FrequencyUnit(self): # -> None:
        ...
    


class Probe(Group):
    """Wrapper for Group of type `probe`.

    This is a structured variable that describes the probe (source-detector) 
    geometry.  This variable has a number of required fields.

    """
    def __init__(self, var, cfg: SnirfConfig) -> None:
        ...
    
    @property
    def wavelengths(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `wavelengths`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field describes the "nominal" wavelengths used (in `nm` unit).  This is indexed by the 
        `wavelengthIndex` of the measurementList variable. For example, `probe.wavelengths` = [690, 
        780, 830]; implies that the measurements were taken at three wavelengths (690 nm, 
        780 nm, and 830 nm).  The wavelength index of 
        `measurementList(k).wavelengthIndex` variable refers to this field.
        `measurementList(k).wavelengthIndex` = 2 means the k<sup>th</sup> measurement 
        was at 780 nm.

        Please note that this field stores the "nominal" wavelengths. If the precise 
        (measured) wavelengths differ from the nominal wavelengths, one can store those
        in the `measurementList.wavelengthActual` field in a per-channel fashion.

        The number of wavelengths is not limited (except that at least two are needed 
        to calculate the two forms of hemoglobin).  Each source-detector pair would 
        generally have measurements at all wavelengths.

        This field must present, but can be empty, for example, in the case that the stored
        data are processed data (`dataType=99999`, see Appendix).


        """
        ...
    
    @wavelengths.setter
    def wavelengths(self, value): # -> None:
        ...
    
    @wavelengths.deleter
    def wavelengths(self): # -> None:
        ...
    
    @property
    def wavelengthsEmission(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `wavelengthsEmission`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field is required only for fluorescence data types, and describes the 
        "nominal" emission wavelengths used (in `nm` unit).  The indexing of this variable is the same 
        wavelength index in measurementList used for `probe.wavelengths` such that the 
        excitation wavelength is paired with this emission wavelength for a given measurement.

        Please note that this field stores the "nominal" emission wavelengths. If the precise 
        (measured) emission wavelengths differ from the nominal ones, one can store those
        in the `measurementList.wavelengthEmissionActual` field in a per-channel fashion.


        """
        ...
    
    @wavelengthsEmission.setter
    def wavelengthsEmission(self, value): # -> None:
        ...
    
    @wavelengthsEmission.deleter
    def wavelengthsEmission(self): # -> None:
        ...
    
    @property
    def sourcePos2D(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `sourcePos2D`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field describes the position (in `LengthUnit` units) of each source 
        optode. The positions are coordinates in a flattened 2D probe layout. 
        This field has size `<number of sources> x 2`. For example, 
        `probe.sourcePos2D(1,:) = [1.4 1]`, and `LengthUnit='cm'` places source 
        number 1 at x=1.4 cm and y=1 cm.


        """
        ...
    
    @sourcePos2D.setter
    def sourcePos2D(self, value): # -> None:
        ...
    
    @sourcePos2D.deleter
    def sourcePos2D(self): # -> None:
        ...
    
    @property
    def sourcePos3D(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `sourcePos3D`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field describes the position (in `LengthUnit` units) of each source 
        optode in 3D. This field has size `<number of sources> x 3`.


        """
        ...
    
    @sourcePos3D.setter
    def sourcePos3D(self, value): # -> None:
        ...
    
    @sourcePos3D.deleter
    def sourcePos3D(self): # -> None:
        ...
    
    @property
    def detectorPos2D(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `detectorPos2D`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Same as `probe.sourcePos2D`, but describing the detector positions in a 
        flattened 2D probe layout.


        """
        ...
    
    @detectorPos2D.setter
    def detectorPos2D(self, value): # -> None:
        ...
    
    @detectorPos2D.deleter
    def detectorPos2D(self): # -> None:
        ...
    
    @property
    def detectorPos3D(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `detectorPos3D`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field describes the position (in `LengthUnit` units) of each detector 
        optode in 3D, defined similarly to `sourcePos3D`.


        """
        ...
    
    @detectorPos3D.setter
    def detectorPos3D(self, value): # -> None:
        ...
    
    @detectorPos3D.deleter
    def detectorPos3D(self): # -> None:
        ...
    
    @property
    def frequencies(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `frequencies`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field describes the frequencies used (in `FrequencyUnit` units)  for 
        frequency domain measurements. This field is only required for frequency 
        domain data types, and is indexed by `measurementList(k).dataTypeIndex`.


        """
        ...
    
    @frequencies.setter
    def frequencies(self, value): # -> None:
        ...
    
    @frequencies.deleter
    def frequencies(self): # -> None:
        ...
    
    @property
    def timeDelays(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `timeDelays`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field describes the time delays (in `TimeUnit` units) used for gated time domain measurements. 
        This field is only required for gated time domain data types, and is indexed by 
        `measurementList(k).dataTypeIndex`. The indexing of this field is paired with 
        the indexing of `probe.timeDelayWidths`. 


        """
        ...
    
    @timeDelays.setter
    def timeDelays(self, value): # -> None:
        ...
    
    @timeDelays.deleter
    def timeDelays(self): # -> None:
        ...
    
    @property
    def timeDelayWidths(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `timeDelayWidths`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field describes the time delay widths (in `TimeUnit` units) used for gated time domain 
        measurements. This field is only required for gated time domain data types, and 
        is indexed by `measurementList(k).dataTypeIndex`.  The indexing of this field 
        is paired with the indexing of `probe.timeDelays`.


        """
        ...
    
    @timeDelayWidths.setter
    def timeDelayWidths(self, value): # -> None:
        ...
    
    @timeDelayWidths.deleter
    def timeDelayWidths(self): # -> None:
        ...
    
    @property
    def momentOrders(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `momentOrders`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field describes the moment orders of the temporal point spread function (TPSF) or the distribution of time-of-flight (DTOF)
        for moment time domain measurements. This field is only required for moment time domain data types, and is indexed by `measurementList(k).dataTypeIndex`.  
        Note that the numeric value in this array is the exponent in the integral used for calculating the moments. For detailed/specific definitions of moments, see [Wabnitz et al, 2020](https://doi.org/10.1364/BOE.396585); for general definitions of moments see [here](https://en.wikipedia.org/wiki/Moment_(mathematics) ).

        In brief, given a TPSF or DTOF N(t) (photon counts vs. photon arrival time at the detector): /
        momentOrder = 0: total counts: `N_total = /intergral N(t)dt` /
        momentOrder = 1: mean time of flight: `m = <t> = (1/N_total) /integral t N(t) dt` /
        momentOrder = 2: variance/second central moment: `V = (1/N_total) /integral (t - <t>)^2 N(t) dt` /
        Please note that all moments (for orders >=1) are expected to be normalized by the total counts (i.e. n=0); Additionally all moments (for orders >= 2) are expected to be centralized.


        """
        ...
    
    @momentOrders.setter
    def momentOrders(self, value): # -> None:
        ...
    
    @momentOrders.deleter
    def momentOrders(self): # -> None:
        ...
    
    @property
    def correlationTimeDelays(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `correlationTimeDelays`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field describes the time delays (in `TimeUnit` units) used for diffuse correlation spectroscopy 
        measurements. This field is only required for diffuse correlation spectroscopy 
        data types, and is indexed by `measurementList(k).dataTypeIndex`.  The indexing 
        of this field is paired with the indexing of `probe.correlationTimeDelayWidths`.


        """
        ...
    
    @correlationTimeDelays.setter
    def correlationTimeDelays(self, value): # -> None:
        ...
    
    @correlationTimeDelays.deleter
    def correlationTimeDelays(self): # -> None:
        ...
    
    @property
    def correlationTimeDelayWidths(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `correlationTimeDelayWidths`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This field describes the time delay widths (in `TimeUnit` units) used for diffuse correlation 
        spectroscopy measurements. This field is only required for gated time domain 
        data types, and is indexed by `measurementList(k).dataTypeIndex`. The indexing 
        of this field is paired with the indexing of `probe.correlationTimeDelays`.  


        """
        ...
    
    @correlationTimeDelayWidths.setter
    def correlationTimeDelayWidths(self, value): # -> None:
        ...
    
    @correlationTimeDelayWidths.deleter
    def correlationTimeDelayWidths(self): # -> None:
        ...
    
    @property
    def sourceLabels(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `sourceLabels`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is a string array providing user friendly or instrument specific labels 
        for each source. Each element of the array must be a unique string among both 
        `probe.sourceLabels` and `probe.detectorLabels`.This can be of size `<number 
        of sources>x 1` or `<number of sources> x <number of 
        wavelengths>`. This is indexed by `measurementList(k).sourceIndex` and 
        `measurementList(k).wavelengthIndex`.


        """
        ...
    
    @sourceLabels.setter
    def sourceLabels(self, value): # -> None:
        ...
    
    @sourceLabels.deleter
    def sourceLabels(self): # -> None:
        ...
    
    @property
    def detectorLabels(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `detectorLabels`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is a string array providing user friendly or instrument specific labels 
        for each detector. Each element of the array must be a unique string among both 
        `probe.sourceLabels` and `probe.detectorLabels`. This is indexed by 
        `measurementList(k).detectorIndex`.


        """
        ...
    
    @detectorLabels.setter
    def detectorLabels(self, value): # -> None:
        ...
    
    @detectorLabels.deleter
    def detectorLabels(self): # -> None:
        ...
    
    @property
    def landmarkPos2D(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `landmarkPos2D`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is a 2-D array storing the neurological landmark positions projected
        along the 2-D (flattened) probe plane in order to map optical data from the
        flattened optode positions to brain anatomy. This array should contain a minimum 
        of 2 columns, representing the x and y coordinates (in `LengthUnit` units)
        of the 2-D projected landmark positions. If a 3rd column presents, it stores 
        the index to the labels of the given landmark. Label names are stored in the 
        `probe.landmarkLabels` subfield. An label index of 0 refers to an undefined landmark. 


        """
        ...
    
    @landmarkPos2D.setter
    def landmarkPos2D(self, value): # -> None:
        ...
    
    @landmarkPos2D.deleter
    def landmarkPos2D(self): # -> None:
        ...
    
    @property
    def landmarkPos3D(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `landmarkPos3D`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is a 2-D array storing the neurological landmark positions measurement 
        from 3-D digitization and tracking systems to facilitate the registration and 
        mapping of optical data to brain anatomy. This array should contain a minimum 
        of 3 columns, representing the x, y and z coordinates (in `LengthUnit` units) 
        of the digitized landmark positions. If a 4th column presents, it stores the 
        index to the labels of the given landmark. Label names are stored in the 
        `probe.landmarkLabels` subfield. An label index of 0 refers to an undefined landmark. 


        """
        ...
    
    @landmarkPos3D.setter
    def landmarkPos3D(self, value): # -> None:
        ...
    
    @landmarkPos3D.deleter
    def landmarkPos3D(self): # -> None:
        ...
    
    @property
    def landmarkLabels(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `landmarkLabels`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This string array stores the names of the landmarks. The first string denotes 
        the name of the landmarks with an index of 1 in the 4th column of 
        `probe.landmark`, and so on. One can adopt the commonly used 10-20 landmark 
        names, such as "Nasion", "Inion", "Cz" etc, or use user-defined landmark 
        labels. The landmark label can also use the unique source and detector labels 
        defined in `probe.sourceLabels` and `probe.detectorLabels`, respectively, to 
        associate the given landmark to a specific source or detector. All strings are 
        ASCII encoded char arrays.


        """
        ...
    
    @landmarkLabels.setter
    def landmarkLabels(self, value): # -> None:
        ...
    
    @landmarkLabels.deleter
    def landmarkLabels(self): # -> None:
        ...
    
    @property
    def coordinateSystem(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `coordinateSystem`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Defines the coordinate system for sensor positions.
        The string must be one of the coordinate systems listed in the
        [BIDS specification (Appendix VII)](https://bids-specification.readthedocs.io/en/stable/99-appendices/08-coordinate-systems.html#standard-template-identifiers)
        such as "MNI152NLin2009bAsym", "CapTrak" or "Other".
        If the value "Other" is specified, then a defition of the coordinate
        system must be provided in `/nirs(i)/probe/coordinateSystemDescription`.
        See the [FieldTrip toolbox web page](https://www.fieldtriptoolbox.org/faq/coordsys/)
        for detailed descriptions of different coordinate systems.


        """
        ...
    
    @coordinateSystem.setter
    def coordinateSystem(self, value): # -> None:
        ...
    
    @coordinateSystem.deleter
    def coordinateSystem(self): # -> None:
        ...
    
    @property
    def coordinateSystemDescription(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `coordinateSystemDescription`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Free-form text description of the coordinate system.
        May also include a link to a documentation page or
        paper describing the system in greater detail.
        This field is required if the `coordinateSystem` field is set to "Other".


        """
        ...
    
    @coordinateSystemDescription.setter
    def coordinateSystemDescription(self, value): # -> None:
        ...
    
    @coordinateSystemDescription.deleter
    def coordinateSystemDescription(self): # -> None:
        ...
    
    @property
    def useLocalIndex(self): # -> int | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `useLocalIndex`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        For modular NIRS systems, setting this flag to a non-zero integer indicates 
        that `measurementList(k).sourceIndex` and `measurementList(k).detectorIndex` 
        are module-specific local-indices. One must also include 
        `measurementList(k).moduleIndex`, or when cross-module channels present, both 
        `measurementList(k).sourceModuleIndex` and `measurementList(k).detectorModuleIndex` 
        in the `measurementList` structure in order to restore the global indices 
        of the sources/detectors.


        """
        ...
    
    @useLocalIndex.setter
    def useLocalIndex(self, value): # -> None:
        ...
    
    @useLocalIndex.deleter
    def useLocalIndex(self): # -> None:
        ...
    


class NirsElement(Group):
    """Wrapper for an element of indexed group `Nirs`."""
    def __init__(self, gid: h5py.h5g.GroupID, cfg: SnirfConfig) -> None:
        ...
    
    @property
    def metaDataTags(self): # -> _AbsentGroupType | MetaDataTags | Group | None:
        """SNIRF field `metaDataTags`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        The `metaDataTags` group contains the metadata associated with the measurements.
        Each metadata record is represented as a dataset under this group - with the name of
        the record, i.e. the key, as the dataset's name, and the value of the record as the 
        actual data stored in the dataset. Each metadata record can potentially have different 
        data types. Sub-groups should not be used to organize metadata records: a member of the `metaDataTags` Group must be a Dataset.

        The below five metadata records are minimally required in a SNIRF file

        """
        ...
    
    @metaDataTags.setter
    def metaDataTags(self, value): # -> None:
        ...
    
    @metaDataTags.deleter
    def metaDataTags(self): # -> None:
        ...
    
    @property
    def data(self): # -> _AbsentDatasetType:
        """SNIRF field `data`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This group stores one block of NIRS data.  This can be extended adding the 
        count number (e.g. `data1`, `data2`,...) to the group name.  This is intended to 
        allow the storage of 1 or more blocks of NIRS data from within the same `/nirs` 
        entry
        * `/nirs/data1` =  data block 1
        * `/nirs/data2` =  data block 2 

         
        """
        ...
    
    @data.setter
    def data(self, value): # -> None:
        ...
    
    @data.deleter
    def data(self):
        ...
    
    @property
    def stim(self): # -> _AbsentDatasetType:
        """SNIRF field `stim`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is an array describing any stimulus conditions. Each element of the array 
        has the following required fields.


        """
        ...
    
    @stim.setter
    def stim(self, value): # -> None:
        ...
    
    @stim.deleter
    def stim(self):
        ...
    
    @property
    def probe(self): # -> _AbsentGroupType | Probe | Group | None:
        """SNIRF field `probe`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is a structured variable that describes the probe (source-detector) 
        geometry.  This variable has a number of required fields.

        """
        ...
    
    @probe.setter
    def probe(self, value): # -> None:
        ...
    
    @probe.deleter
    def probe(self): # -> None:
        ...
    
    @property
    def aux(self): # -> _AbsentDatasetType:
        """SNIRF field `aux`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This optional array specifies any recorded auxiliary data. Each element of 
        `aux` has the following required fields:

        """
        ...
    
    @aux.setter
    def aux(self, value): # -> None:
        ...
    
    @aux.deleter
    def aux(self):
        ...
    


class Nirs(IndexedGroup):
    """Interface for indexed group `Nirs`.

    Can be indexed like a list to retrieve `Nirs` elements.

    To add or remove an element from the list, use the `appendGroup` method and the `del` operator, respectively.

    This group stores one set of NIRS data.  This can be extended by adding the count 
    number (e.g. `/nirs1`, `/nirs2`,...) to the group name. This is intended to 
    allow the storage of 1 or more complete NIRS datasets inside a single SNIRF 
    document.  For example, a two-subject hyperscanning can be stored using the notation
    * `/nirs1` =  first subject's data
    * `/nirs2` =  second subject's data
    The use of a non-indexed (e.g. `/nirs`) entry is allowed when only one entry 
    is present and is assumed to be entry 1.


    """
    _name: str = ...
    _element: Group = ...
    def __init__(self, h: h5py.File, cfg: SnirfConfig) -> None:
        ...
    


class DataElement(Group):
    """Wrapper for an element of indexed group `Data`."""
    def __init__(self, gid: h5py.h5g.GroupID, cfg: SnirfConfig) -> None:
        ...
    
    @property
    def dataTimeSeries(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `dataTimeSeries`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is the actual raw or processed data variable. This variable has dimensions 
        of `<number of time points> x <number of channels>`. Columns in 
        `dataTimeSeries` are mapped to the measurement list (`measurementList` variable 
        described below).

        `dataTimeSeries` can be compressed using the HDF5 filter (using the built-in 
        [`deflate`](https://portal.hdfgroup.org/display/HDF5/H5P_SET_DEFLATE)
        filter or [3rd party filters such as `305-LZO` or `307-bzip2`](https://portal.hdfgroup.org/display/support/Registered+Filter+Plugins)

        Chunked data is allowed to support real-time streaming of data in this array. 

        """
        ...
    
    @dataTimeSeries.setter
    def dataTimeSeries(self, value): # -> None:
        ...
    
    @dataTimeSeries.deleter
    def dataTimeSeries(self): # -> None:
        ...
    
    @property
    def time(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `time`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        The `time` variable. This provides the acquisition time of the measurement 
        relative to the time origin.  This will usually be a straight line with slope 
        equal to the acquisition frequency, but does not need to be equal spacing.  For 
        the special case of equal sample spacing an array of length `<2>` is allowed 
        where the first entry is the start time and the 
        second entry is the sample time spacing in `TimeUnit` specified in the 
        `metaDataTags`. The default time unit is in second ("s"). For example, 
        a time spacing of 0.2 (s) indicates a sampling rate of 5 Hz.
          
        * **Option 1** - The size of this variable is `<number of time points>` and 
                     corresponds to the sample time of every data point
        * **Option 2**-  The size of this variable is `<2>` and corresponds to the start
              time and sample spacing.

        Chunked data is allowed to support real-time streaming of data in this array.

        """
        ...
    
    @time.setter
    def time(self, value): # -> None:
        ...
    
    @time.deleter
    def time(self): # -> None:
        ...
    
    @property
    def measurementList(self): # -> _AbsentDatasetType:
        """SNIRF field `measurementList`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        The measurement list. This variable serves to map the data array onto the probe 
        geometry (sources and detectors), data type, and wavelength. This variable is 
        an array structure that has the size `<number of channels>` that 
        describes the corresponding column in the data matrix. For example, the 
        `measurementList3` describes the third column of the data matrix (i.e. 
        `dataTimeSeries(:,3)`).

        Each element of the array is a structure which describes the measurement 
        conditions for this data with the following fields:


        """
        ...
    
    @measurementList.setter
    def measurementList(self, value): # -> None:
        ...
    
    @measurementList.deleter
    def measurementList(self):
        ...
    


class Data(IndexedGroup):
    """Interface for indexed group `Data`.

    Can be indexed like a list to retrieve `Data` elements.

    To add or remove an element from the list, use the `appendGroup` method and the `del` operator, respectively.

    This group stores one block of NIRS data.  This can be extended adding the 
    count number (e.g. `data1`, `data2`,...) to the group name.  This is intended to 
    allow the storage of 1 or more blocks of NIRS data from within the same `/nirs` 
    entry
    * `/nirs/data1` =  data block 1
    * `/nirs/data2` =  data block 2 

     
    """
    _name: str = ...
    _element: Group = ...
    def __init__(self, h: h5py.File, cfg: SnirfConfig) -> None:
        ...
    


class MeasurementListElement(Group):
    """Wrapper for an element of indexed group `MeasurementList`."""
    def __init__(self, gid: h5py.h5g.GroupID, cfg: SnirfConfig) -> None:
        ...
    
    @property
    def sourceIndex(self): # -> int | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `sourceIndex`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Index of the source.
         
        """
        ...
    
    @sourceIndex.setter
    def sourceIndex(self, value): # -> None:
        ...
    
    @sourceIndex.deleter
    def sourceIndex(self): # -> None:
        ...
    
    @property
    def detectorIndex(self): # -> int | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `detectorIndex`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Index of the detector.

        """
        ...
    
    @detectorIndex.setter
    def detectorIndex(self, value): # -> None:
        ...
    
    @detectorIndex.deleter
    def detectorIndex(self): # -> None:
        ...
    
    @property
    def wavelengthIndex(self): # -> int | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `wavelengthIndex`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Index of the "nominal" wavelength (in `probe.wavelengths`).

        """
        ...
    
    @wavelengthIndex.setter
    def wavelengthIndex(self, value): # -> None:
        ...
    
    @wavelengthIndex.deleter
    def wavelengthIndex(self): # -> None:
        ...
    
    @property
    def wavelengthActual(self): # -> float | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `wavelengthActual`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Actual (measured) wavelength in nm, if available, for the source in a given channel.

        """
        ...
    
    @wavelengthActual.setter
    def wavelengthActual(self, value): # -> None:
        ...
    
    @wavelengthActual.deleter
    def wavelengthActual(self): # -> None:
        ...
    
    @property
    def wavelengthEmissionActual(self): # -> float | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `wavelengthEmissionActual`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Actual (measured) emission wavelength in nm, if available, for the source in a given channel.
         
        """
        ...
    
    @wavelengthEmissionActual.setter
    def wavelengthEmissionActual(self, value): # -> None:
        ...
    
    @wavelengthEmissionActual.deleter
    def wavelengthEmissionActual(self): # -> None:
        ...
    
    @property
    def dataType(self): # -> int | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `dataType`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Data-type identifier. See Appendix for list possible values.

        """
        ...
    
    @dataType.setter
    def dataType(self, value): # -> None:
        ...
    
    @dataType.deleter
    def dataType(self): # -> None:
        ...
    
    @property
    def dataUnit(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `dataUnit`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        International System of Units (SI units) identifier for the given channel. Encoding should follow the [CMIXF-12 standard](https://people.csail.mit.edu/jaffer/MIXF/CMIXF-12), avoiding special unicode symbols like U+03BC (m) or U+00B5 (u) and using '/' rather than 'per' for units such as `V/us`. The recommended export format is in unscaled units such as V, s, Mole.

        """
        ...
    
    @dataUnit.setter
    def dataUnit(self, value): # -> None:
        ...
    
    @dataUnit.deleter
    def dataUnit(self): # -> None:
        ...
    
    @property
    def dataTypeLabel(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `dataTypeLabel`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Data-type label. Only required if dataType is "processed" (`99999`). See Appendix 
        for list of possible values.

        """
        ...
    
    @dataTypeLabel.setter
    def dataTypeLabel(self, value): # -> None:
        ...
    
    @dataTypeLabel.deleter
    def dataTypeLabel(self): # -> None:
        ...
    
    @property
    def dataTypeIndex(self): # -> int | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `dataTypeIndex`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Data-type specific parameter indices. The data type index specifies additional data type specific parameters that are further elaborated by other fields in the probe structure, as detailed below. Note that the Time Domain and Diffuse Correlation Spectroscopy data types have two additional parameters and so the data type index must be a vector with 2 elements that index the additional parameters. One use of this parameter is as a 
        stimulus condition index when `measurementList(k).dataType = 99999` (i.e, `processed` and 
        `measurementList(k).dataTypeLabel = 'HRF ...'` .

        """
        ...
    
    @dataTypeIndex.setter
    def dataTypeIndex(self, value): # -> None:
        ...
    
    @dataTypeIndex.deleter
    def dataTypeIndex(self): # -> None:
        ...
    
    @property
    def sourcePower(self): # -> float | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `sourcePower`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        The units are not defined, unless the user takes the option of using a `metaDataTag` as described below.

        """
        ...
    
    @sourcePower.setter
    def sourcePower(self, value): # -> None:
        ...
    
    @sourcePower.deleter
    def sourcePower(self): # -> None:
        ...
    
    @property
    def detectorGain(self): # -> float | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `detectorGain`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Detector gain

        """
        ...
    
    @detectorGain.setter
    def detectorGain(self, value): # -> None:
        ...
    
    @detectorGain.deleter
    def detectorGain(self): # -> None:
        ...
    
    @property
    def moduleIndex(self): # -> int | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `moduleIndex`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Index of a repeating module. If `moduleIndex` is provided while `useLocalIndex`
        is set to `true`, then, both `measurementList(k).sourceIndex` and 
        `measurementList(k).detectorIndex` are assumed to be the local indices
        of the same module specified by `moduleIndex`. If the source and
        detector are located on different modules, one must use `sourceModuleIndex`
        and `detectorModuleIndex` instead to specify separate parent module 
        indices. See below.


        """
        ...
    
    @moduleIndex.setter
    def moduleIndex(self, value): # -> None:
        ...
    
    @moduleIndex.deleter
    def moduleIndex(self): # -> None:
        ...
    
    @property
    def sourceModuleIndex(self): # -> int | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `sourceModuleIndex`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Index of the module that contains the source of the channel. 
        This index must be used together with `detectorModuleIndex`, and 
        can not be used when `moduleIndex` presents.

        """
        ...
    
    @sourceModuleIndex.setter
    def sourceModuleIndex(self, value): # -> None:
        ...
    
    @sourceModuleIndex.deleter
    def sourceModuleIndex(self): # -> None:
        ...
    
    @property
    def detectorModuleIndex(self): # -> int | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `detectorModuleIndex`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        Index of the module that contains the detector of the channel. 
        This index must be used together with `sourceModuleIndex`, and 
        can not be used when `moduleIndex` presents.


        For example, if `measurementList5` is a structure with `sourceIndex=2`, 
        `detectorIndex=3`, `wavelengthIndex=1`, `dataType=1`, `dataTypeIndex=1` would 
        imply that the data in the 5th column of the `dataTimeSeries` variable was 
        measured with source #2 and detector #3 at wavelength #1.  Wavelengths (in 
        nanometers) are described in the `probe.wavelengths` variable  (described 
        later). The data type in this case is 1, implying that it was a continuous wave 
        measurement.  The complete list of currently supported data types is found in 
        the Appendix. The data type index specifies additional data type specific 
        parameters that are further elaborated by other fields in the `probe` 
        structure, as detailed below. Note that the Time Domain and Diffuse Correlation 
        Spectroscopy data types have two additional parameters and so the data type 
        index must be a vector with 2 elements that index the additional parameters.

        `sourcePower` provides the option for information about the source power for 
        that channel to be saved along with the data. The units are not defined, unless 
        the user takes the option of using a `metaDataTag` described below to define, 
        for instance, `sourcePowerUnit`. `detectorGain` provides the option for 
        information about the detector gain for that channel to be saved along with the 
        data.

        Note:  The source indices generally refer to the optode naming (probe 
        positions) and not necessarily the physical laser numbers on the instrument. 
        The same is true for the detector indices.  Each source optode would generally, 
        but not necessarily, have 2 or more wavelengths (hence lasers) plugged into it 
        in order to calculate deoxy- and oxy-hemoglobin concentrations. The data from 
        these two wavelengths will be indexed by the same source, detector, and data 
        type values, but have different wavelength indices. Using the same source index 
        for lasers at the same location but with different wavelengths simplifies the 
        bookkeeping for converting intensity measurements into concentration changes. 
        As described below, optional variables `probe.sourceLabels` and 
        `probe.detectorLabels` are provided for indicating the instrument specific 
        label for sources and detectors.

        """
        ...
    
    @detectorModuleIndex.setter
    def detectorModuleIndex(self, value): # -> None:
        ...
    
    @detectorModuleIndex.deleter
    def detectorModuleIndex(self): # -> None:
        ...
    


class MeasurementList(IndexedGroup):
    """Interface for indexed group `MeasurementList`.

    Can be indexed like a list to retrieve `MeasurementList` elements.

    To add or remove an element from the list, use the `appendGroup` method and the `del` operator, respectively.

    The measurement list. This variable serves to map the data array onto the probe 
    geometry (sources and detectors), data type, and wavelength. This variable is 
    an array structure that has the size `<number of channels>` that 
    describes the corresponding column in the data matrix. For example, the 
    `measurementList3` describes the third column of the data matrix (i.e. 
    `dataTimeSeries(:,3)`).

    Each element of the array is a structure which describes the measurement 
    conditions for this data with the following fields:


    """
    _name: str = ...
    _element: Group = ...
    def __init__(self, h: h5py.File, cfg: SnirfConfig) -> None:
        ...
    


class StimElement(Group):
    """Wrapper for an element of indexed group `Stim`."""
    def __init__(self, gid: h5py.h5g.GroupID, cfg: SnirfConfig) -> None:
        ...
    
    @property
    def name(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `name`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is a string describing the j<sup>th</sup> stimulus condition.


        """
        ...
    
    @name.setter
    def name(self, value): # -> None:
        ...
    
    @name.deleter
    def name(self): # -> None:
        ...
    
    @property
    def data(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `data`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        * **Allowed attribute**: `names`

        This is a numeric 2-D array with at least 3 columns, specifying the stimulus 
        time course for the j<sup>th</sup> condition. Each row corresponds to a 
        specific stimulus trial. The first three columns indicate `[starttime duration value]`.  
        The starttime, in seconds, is the time relative to the time origin when the 
        stimulus takes on a value; the duration is the time in seconds that the stimulus 
        value continues, and value is the stimulus amplitude.  The number of rows is 
        not constrained. (see examples in the appendix).

        Additional columns can be used to store user-specified data associated with 
        each stimulus trial. An optional record `/nirs(i)/stim(j)/dataLabels` can be 
        used to annotate the meanings of each data column. 

        """
        ...
    
    @data.setter
    def data(self, value): # -> None:
        ...
    
    @data.deleter
    def data(self): # -> None:
        ...
    
    @property
    def dataLabels(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `dataLabels`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is a string array providing annotations for each data column in 
        `/nirs(i)/stim(j)/data`. Each element of the array must be a string;
        the total length of this array must be the same as the column number
        of `/nirs(i)/stim(j)/data`, including the first 3 required columns.

        """
        ...
    
    @dataLabels.setter
    def dataLabels(self, value): # -> None:
        ...
    
    @dataLabels.deleter
    def dataLabels(self): # -> None:
        ...
    


class Stim(IndexedGroup):
    """Interface for indexed group `Stim`.

    Can be indexed like a list to retrieve `Stim` elements.

    To add or remove an element from the list, use the `appendGroup` method and the `del` operator, respectively.

    This is an array describing any stimulus conditions. Each element of the array 
    has the following required fields.


    """
    _name: str = ...
    _element: Group = ...
    def __init__(self, h: h5py.File, cfg: SnirfConfig) -> None:
        ...
    


class AuxElement(Group):
    """Wrapper for an element of indexed group `Aux`."""
    def __init__(self, gid: h5py.h5g.GroupID, cfg: SnirfConfig) -> None:
        ...
    
    @property
    def name(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `name`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is string describing the j<sup>th</sup> auxiliary data timecourse. While auxiliary data can be given any title, standard names for commonly used auxiliary channels (i.e. accelerometer data) are specified in the appendix.

        """
        ...
    
    @name.setter
    def name(self, value): # -> None:
        ...
    
    @name.deleter
    def name(self): # -> None:
        ...
    
    @property
    def dataTimeSeries(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `dataTimeSeries`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is the aux data variable. This variable has dimensions of `<number of 
        time points> x <number of channels>`. If multiple channels of related data are generated by a system, they may be encoded in the multiple columns of the time series (i.e. complex numbers). For example, a system containing more than one accelerometer may output this data as a set of `ACCEL_X`/`ACCEL_Y`/`ACCEL_Z` auxiliary time series, where each has the dimension of `<number of time points> x <number of accelerometers>`. Note that it is NOT recommended to encode the various accelerometer dimensions as multiple channels of the same `aux` Group: instead follow the `"ACCEL_X"`, `"ACCEL_Y"`, `"ACCEL_Z"` naming conventions described in the appendix. Chunked data is allowed to support real-time data streaming.

        """
        ...
    
    @dataTimeSeries.setter
    def dataTimeSeries(self, value): # -> None:
        ...
    
    @dataTimeSeries.deleter
    def dataTimeSeries(self): # -> None:
        ...
    
    @property
    def dataUnit(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `dataUnit`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        International System of Units (SI units) identifier for the given channel. Encoding should follow the [CMIXF-12 standard](https://people.csail.mit.edu/jaffer/MIXF/CMIXF-12), avoiding special unicode symbols like U+03BC (m) or U+00B5 (u) and using '/' rather than 'per' for units such as `V/us`. The recommended export format is in unscaled units such as V, s, Mole.

        """
        ...
    
    @dataUnit.setter
    def dataUnit(self, value): # -> None:
        ...
    
    @dataUnit.deleter
    def dataUnit(self): # -> None:
        ...
    
    @property
    def time(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `time`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        The time variable. This provides the acquisition time (in `TimeUnit` units) 
        of the aux measurement relative to the time origin.  This will usually be 
        a straight line with slope equal to the acquisition frequency, but does 
        not need to be equal spacing. The size of this variable is 
        `<number of time points>` or `<2>` similar  to definition of the 
        `/nirs(i)/data(j)/time` field.

        Chunked data is allowed to support real-time data streaming

        """
        ...
    
    @time.setter
    def time(self, value): # -> None:
        ...
    
    @time.deleter
    def time(self): # -> None:
        ...
    
    @property
    def timeOffset(self): # -> ndarray[Unknown, Unknown] | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `timeOffset`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This variable specifies the offset of the file time origin relative to absolute
        (clock) time in `TimeUnit` units.



        """
        ...
    
    @timeOffset.setter
    def timeOffset(self, value): # -> None:
        ...
    
    @timeOffset.deleter
    def timeOffset(self): # -> None:
        ...
    


class Aux(IndexedGroup):
    """Interface for indexed group `Aux`.

    Can be indexed like a list to retrieve `Aux` elements.

    To add or remove an element from the list, use the `appendGroup` method and the `del` operator, respectively.

    This optional array specifies any recorded auxiliary data. Each element of 
    `aux` has the following required fields:

    """
    _name: str = ...
    _element: Group = ...
    def __init__(self, h: h5py.File, cfg: SnirfConfig) -> None:
        ...
    


class Snirf(Group):
    _name = ...
    def __init__(self, *args, dynamic_loading: bool = ..., enable_logging: bool = ...) -> None:
        ...
    
    @property
    def formatVersion(self): # -> str | _AbsentDatasetType | _PresentDatasetType | None:
        """SNIRF field `formatVersion`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This is a string that specifies the version of the file format.  This document 
        describes format version "1.0"
         
        """
        ...
    
    @formatVersion.setter
    def formatVersion(self, value): # -> None:
        ...
    
    @formatVersion.deleter
    def formatVersion(self): # -> None:
        ...
    
    @property
    def nirs(self): # -> _AbsentDatasetType:
        """SNIRF field `nirs`.

        If dynamic_loading=True, the data is loaded from the SNIRF file only
        when accessed through the getter

        This group stores one set of NIRS data.  This can be extended by adding the count 
        number (e.g. `/nirs1`, `/nirs2`,...) to the group name. This is intended to 
        allow the storage of 1 or more complete NIRS datasets inside a single SNIRF 
        document.  For example, a two-subject hyperscanning can be stored using the notation
        * `/nirs1` =  first subject's data
        * `/nirs2` =  second subject's data
        The use of a non-indexed (e.g. `/nirs`) entry is allowed when only one entry 
        is present and is assumed to be entry 1.


        """
        ...
    
    @nirs.setter
    def nirs(self, value): # -> None:
        ...
    
    @nirs.deleter
    def nirs(self):
        ...
    


_RECOGNIZED_COORDINATE_SYSTEM_NAMES = ...
class MetaDataTags(MetaDataTags):
    def add(self, name, value): # -> None:
        """Add a new tag to the list.
        
        Args:
            name (str): The name of the tag to add (will be added as an attribute of this `MetaDataTags` instance)
            value: The value of the new tag
        """
        ...
    
    def remove(self, name): # -> None:
        """Remove a tag from the list. You cannot remove a required tag.
        
        Args:
            name (str): The name of the tag to remove.
        """
        ...
    


class StimElement(StimElement):
    ...


class Stim(Stim):
    _element = ...


class AuxElement(AuxElement):
    ...


class Aux(Aux):
    _element = ...


class DataElement(DataElement):
    ...


class Data(Data):
    _element = ...


class Probe(Probe):
    ...


class Snirf(Snirf):
    def save(self, *args): # -> None:
        """Save a SNIRF file to disk.

        Args:
            args (str or h5py.File or file-like): A path to a closed or nonexistant SNIRF file on disk or an open `h5py.File` instance

        Examples:
            save can overwrite the current contents of a Snirf file:
            >>> mysnirf.save()

            or take a new filename to write the file there:
            >>> mysnirf.save(<new destination>)
            
            or write to an IO stream:
            >>> mysnirf.save(<io.BytesIO stream>)
        """
        ...
    
    def copy(self) -> Snirf:
        """Return a copy of the Snirf instance.
            
        A copy of a Snirf instance is a brand new HDF5 file in memory. This can 
        be expensive to create. Note that in lieu of copying you can make assignments
        between Snirf instances. 
        """
        ...
    
    def validate(self) -> ValidationResult:
        """Validate a `Snirf` instance.

        Returns the validity of the current state of a `Snirf` object, including
        modifications made in memory to a loaded SNIRF file.

        Returns:
            ValidationResult: truthy structure containing detailed validation results
        """
        ...
    
    @property
    def filename(self): # -> None:
        """The filename the Snirf object was loaded from and will save to."""
        ...
    
    def close(self): # -> None:
        """Close the file underlying a `Snirf` instance.

        After closing, the underlying SNIRF file cannot be accessed from this interface again.
        Use `close` if you need to open a new interface on the same HDF5 file.

        `close` is called automatically by the destructor.
        """
        ...
    
    def __enter__(self): # -> Self@Snirf:
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb): # -> bool:
        ...
    
    def __getitem__(self, key): # -> None:
        ...
    


def loadSnirf(path: str, dynamic_loading: bool = ..., enable_logging: bool = ...) -> Snirf:
    """Load a SNIRF file from disk.
    
    Returns a `Snirf` object loaded from path if a SNIRF file exists there. Takes
    the same kwargs as the Snirf object constructor
    
    Args:
        path (str): Path to a SNIRF file on disk.
        dynamic_loading (bool): If True, Datasets will not be read from the SNIRF file
            unless accessed with a property, conserving memory and loading time with larger datasets. Default False.
        enable_logging (bool): If True, the `Snirf` instance will write to a log file which shares its name. Default False.
    
    Returns:
        `Snirf`: a `Snirf` instance loaded from the SNIRF file.   
    
    Raises:
        FileNotFoundError: `path` was not found on disk.
    """
    ...

def saveSnirf(path: str, snirf: Snirf): # -> None:
    """Saves a SNIRF file to disk.
    
    Args:
        path (str): Path to save the file.
        snirf (Snirf): `Snirf` instance to write to disk.
    """
    ...

def validateSnirf(path: str) -> ValidationResult:
    """Validate a SNIRF file on disk.
    
    Returns truthy ValidationResult instance which holds detailed results of validation
    """
    ...

